import ArgumentParser
import ApplicationServices
import Foundation
import Logging
import UIGraph
import Skills

@main
struct AgentlyRunner: AsyncParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "agently",
        abstract: "Agently - AI agent for macOS automation via accessibility APIs",
        version: "0.1.0"
    )
    
    @Option(name: .shortAndLong, help: "Task to execute")
    var task: String?
    
    @Option(name: .shortAndLong, help: "Output format (json, text)")
    var format: OutputFormat = .text
    
    @Flag(name: .long, help: "Build UI graph only, don't execute")
    var graphOnly = false
    
    @Flag(name: .long, help: "Enable verbose logging")
    var verbose = false
    
    @Flag(name: .long, help: "Run accessibility permission preflight check")
    var preflight = false
    
    func run() async throws {
        setupLogging()
        
        if preflight {
            try await runPreflightCheck()
            return
        }
        
        if graphOnly {
            try await buildAndOutputGraph()
            return
        }
        
        guard let task = task else {
            throw ValidationError("Task is required unless using --graph-only or --preflight")
        }
        
        try await executeTask(task)
    }
    
    private func setupLogging() {
        LoggingSystem.bootstrap { label in
            var handler = StreamLogHandler.standardOutput(label: label)
            handler.logLevel = verbose ? .debug : .info
            return handler
        }
    }
    
    private func runPreflightCheck() async throws {
        let logger = Logger(label: "PreflightCheck")
        logger.info("Running accessibility preflight check...")
        
        // Check accessibility permissions
        let trusted = AXIsProcessTrusted()
        
        if trusted {
            logger.info("✅ Accessibility permissions granted")
        } else {
            logger.warning("❌ Accessibility permissions not granted")
            logger.info("Please grant accessibility access in System Settings > Privacy & Security > Accessibility")
            
            // Try to trigger permission prompt
            let options = ["AXTrustedCheckOptionPrompt" as CFString: true] as CFDictionary
            let _ = AXIsProcessTrustedWithOptions(options)
        }
        
        // Test basic graph building
        do {
            let graphBuilder = AccessibilityGraphBuilder()
            let graph = try graphBuilder.buildGraph()
            logger.info("✅ Successfully built UI graph with \(graph.elements.count) elements")
        } catch {
            logger.error("❌ Failed to build UI graph: \(error)")
            throw error
        }
        
        logger.info("Preflight check complete")
    }
    
    private func buildAndOutputGraph() async throws {
        let logger = Logger(label: "GraphBuilder")
        logger.info("Building UI accessibility graph...")
        
        let graphBuilder = AccessibilityGraphBuilder()
        let graph = try graphBuilder.buildGraph()
        
        switch format {
        case .json:
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            encoder.dateEncodingStrategy = .iso8601
            
            let data = try encoder.encode(graph)
            if let jsonString = String(data: data, encoding: .utf8) {
                print(jsonString)
            }
            
        case .text:
            printGraphSummary(graph, logger: logger)
        }
    }
    
    private func executeTask(_ taskDescription: String) async throws {
        let logger = Logger(label: "TaskExecution")
        logger.info("Executing task: \(taskDescription)")
        
        // 1. Build initial UI graph
        let graphBuilder = AccessibilityGraphBuilder()
        let initialGraph = try graphBuilder.buildGraph()
        logger.info("Built initial graph with \(initialGraph.elements.count) elements")
        
        // 2. Call Python planner to generate action plan
        let plannerResult = try await callPythonPlanner(task: taskDescription, graph: initialGraph)
        
        guard let actions = plannerResult["actions"] as? [[String: Any]] else {
            throw AgentlyError.planningFailed("No actions generated by planner")
        }
        
        logger.info("Generated plan with \(actions.count) actions")
        
        // 3. Execute actions
        let skillExecutor = SkillExecutor()
        var currentGraph = initialGraph
        var executedActions: [SkillResult] = []
        
        for (index, actionData) in actions.enumerated() {
            logger.info("Executing action \(index + 1)/\(actions.count)")
            
            do {
                let action = parseAction(from: actionData)
                let result = skillExecutor.execute(action, in: currentGraph)
                executedActions.append(result)
                
                if !result.success {
                    logger.error("Action failed: \(result.errorMessage ?? "unknown error")")
                    
                    // Try to recover
                    currentGraph = try graphBuilder.buildGraph()
                    let recoveryPlan = try await callPythonPlannerForRecovery(
                        task: taskDescription,
                        graph: currentGraph,
                        failedAction: actionData,
                        error: result.errorMessage ?? "unknown error",
                        completedActions: executedActions
                    )
                    
                    // Continue with recovery actions if available
                    if let recoveryActions = recoveryPlan["actions"] as? [[String: Any]], !recoveryActions.isEmpty {
                        logger.info("Attempting recovery with \(recoveryActions.count) actions")
                        // Execute recovery actions (simplified for now)
                    } else {
                        logger.error("No recovery plan available, stopping execution")
                        break
                    }
                }
                
                // Update graph after successful action
                if result.success {
                    // Small delay to let UI settle
                    try await Task.sleep(for: .milliseconds(500))
                    currentGraph = try graphBuilder.buildGraph()
                }
                
            } catch {
                logger.error("Failed to execute action: \(error)")
                break
            }
        }
        
        // Output results
        let successCount = executedActions.filter { $0.success }.count
        logger.info("Task execution complete: \(successCount)/\(executedActions.count) actions successful")
        
        if format == .json {
            let results: [String: Any] = [
                "task": taskDescription,
                "total_actions": executedActions.count,
                "successful_actions": successCount,
                "execution_time": executedActions.reduce(0) { $0 + $1.executionTime },
                "actions": executedActions.map { result in
                    [
                        "type": result.action.type.rawValue,
                        "description": result.action.description,
                        "success": result.success,
                        "execution_time": result.executionTime,
                        "error": result.errorMessage as Any
                    ]
                }
            ]
            
            let data = try JSONSerialization.data(withJSONObject: results, options: .prettyPrinted)
            if let jsonString = String(data: data, encoding: .utf8) {
                print(jsonString)
            }
        }
    }
    
    private func callPythonPlanner(task: String, graph: UIGraph) async throws -> [String: Any] {
        // Convert graph to JSON for Python consumption
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let graphData = try encoder.encode(graph)
        
        // Write graph to temporary file
        let tempGraphFile = URL(fileURLWithPath: "/tmp/agently_graph.json")
        try graphData.write(to: tempGraphFile)
        
        // Call Python planner script using virtual environment
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/bin/bash")
        process.arguments = ["-c", "cd \(FileManager.default.currentDirectoryPath) && source venv/bin/activate && python3 -m planner.main --task '\(task)' --graph '\(tempGraphFile.path)'"]
        
        let pipe = Pipe()
        process.standardOutput = pipe
        
        try process.run()
        process.waitUntilExit()
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        guard let output = String(data: data, encoding: .utf8) else {
            throw AgentlyError.planningFailed("No output from planner")
        }
        
        // Clean up
        try? FileManager.default.removeItem(at: tempGraphFile)
        
        guard let jsonData = output.data(using: .utf8),
              let result = try JSONSerialization.jsonObject(with: jsonData) as? [String: Any] else {
            throw AgentlyError.planningFailed("Invalid JSON response from planner")
        }
        
        return result
    }
    
    private func callPythonPlannerForRecovery(
        task: String,
        graph: UIGraph,
        failedAction: [String: Any],
        error: String,
        completedActions: [SkillResult]
    ) async throws -> [String: Any] {
        // Similar to callPythonPlanner but for error recovery
        // Implementation simplified for brevity
        return ["actions": []]
    }
    
    private func parseAction(from data: [String: Any]) -> SkillAction {
        let type = ActionType(rawValue: data["type"] as? String ?? "") ?? .click
        let targetElementId = data["target_element_id"] as? String
        let parameters = data["parameters"] as? [String: String] ?? [:]
        let description = data["description"] as? String ?? "Unknown action"
        
        return SkillAction(
            type: type,
            targetElementId: targetElementId,
            parameters: parameters,
            description: description
        )
    }
    
    private func printGraphSummary(_ graph: UIGraph, logger: Logger) {
        logger.info("UI Graph Summary:")
        logger.info("- Timestamp: \(graph.timestamp)")
        logger.info("- Active Application: \(graph.activeApplication ?? "None")")
        logger.info("- Total Elements: \(graph.elements.count)")
        logger.info("- Root Elements: \(graph.rootElements.count)")
        
        // Count by role
        let roleCounts = Dictionary(grouping: graph.elements.values) { $0.role }
            .mapValues { $0.count }
        
        logger.info("- Element Types:")
        for (role, count) in roleCounts.sorted(by: { $0.value > $1.value }) {
            logger.info("  - \(role): \(count)")
        }
        
        // Show some example elements
        let interactiveElements = graph.elements.values.filter { element in
            ["AXButton", "AXTextField", "AXMenuButton", "AXCheckBox"].contains(element.role)
        }
        
        if !interactiveElements.isEmpty {
            logger.info("- Sample Interactive Elements:")
            for element in Array(interactiveElements.prefix(5)) {
                let label = element.label ?? element.title ?? "unlabeled"
                logger.info("  - \(element.role): '\(label)' [\(element.id)]")
            }
        }
    }
}

enum OutputFormat: String, ExpressibleByArgument, CaseIterable {
    case json
    case text
}

enum AgentlyError: Error, LocalizedError {
    case planningFailed(String)
    case executionFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .planningFailed(let message):
            return "Planning failed: \(message)"
        case .executionFailed(let message):
            return "Execution failed: \(message)"
        }
    }
}
